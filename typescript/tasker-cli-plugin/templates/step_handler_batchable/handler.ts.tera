import {
  BatchableStepHandler,
  type StepContext,
  type StepHandlerResult,
} from '@tasker-systems/tasker';

/**
 * {{ name | pascal_case }} batchable step handler.
 *
 * Implements batch processing for parallel work distribution.
 * Extends BatchableStepHandler for cursor config creation,
 * worker outcome building, and aggregation helpers.
 *
 * Workflow pattern:
 *   1. Analyzer step: creates cursor configs dividing work into batches
 *   2. Worker steps: process individual batches in parallel
 *   3. Aggregator step: combines results from all workers
 *
 * Register this handler in your task definition YAML:
 *   handler:
 *     callable: {{ name | pascal_case }}Handler
 */
export class {{ name | pascal_case }}Handler extends BatchableStepHandler {
  static handlerName = '{{ name | snake_case }}';
  static handlerVersion = '1.0.0';

  async call(context: StepContext): Promise<StepHandlerResult> {
    // Check if this is a batch worker invocation
    const batchInputs = context.stepInputs || {};
    if (batchInputs['cursor'] || batchInputs['is_no_op']) {
      return this.processBatch(context);
    }

    // Otherwise, this is the analyzer
    return this.analyzeAndCreateBatches(context);
  }

  private analyzeAndCreateBatches(context: StepContext): StepHandlerResult {
    // TODO: Determine total items from your data source
    const totalItems = context.getInput<number>('total_items') || 1000;
    const workerCount = (context.stepConfig['worker_count'] as number) || 5;

    const batchConfigs = this.createCursorConfigs(totalItems, workerCount);

    return this.batchSuccess(
      '{{ name | snake_case }}_batch',
      batchConfigs,
      { analyzed_at: new Date().toISOString() },
    );
  }

  private processBatch(context: StepContext): StepHandlerResult {
    // Handle no-op placeholder
    const noOpResult = this.handleNoOpWorker(context);
    if (noOpResult) {
      return noOpResult;
    }

    const batchCtx = this.getBatchContext(context);
    if (!batchCtx) {
      return this.failure('No batch context found');
    }

    // TODO: Process items in the batch range
    const itemsProcessed = batchCtx.endCursor - batchCtx.startCursor;

    const outcome = this.createWorkerOutcome(itemsProcessed, itemsProcessed);
    return this.batchWorkerSuccess(outcome);
  }
}
