import { defineBatchAnalyzer, defineBatchWorker, defineHandler } from '@tasker-systems/tasker';

/**
 * {{ name | pascal_case }} batchable step handlers for parallel processing.
 *
 * Workflow pattern:
 *   1. Analyzer step: returns BatchConfig to divide work into batches
 *   2. Worker steps: process individual batches in parallel
 *   3. Convergence step: aggregates results from all workers
 *
 * Register handlers in your task definition YAML:
 *   - name: {{ name | snake_case }}_analyze
 *     type: batchable
 *     handler:
 *       callable: {{ name | pascal_case }}AnalyzerHandler
 *   - name: {{ name | snake_case }}_batch
 *     type: batch_worker
 *     dependencies: [{{ name | snake_case }}_analyze]
 *     handler:
 *       callable: {{ name | pascal_case }}WorkerHandler
 *   - name: {{ name | snake_case }}_converge
 *     type: deferred_convergence
 *     dependencies: [{{ name | snake_case }}_batch]
 *     handler:
 *       callable: {{ name | pascal_case }}ConvergenceHandler
 */

export const {{ name | pascal_case }}AnalyzerHandler = defineBatchAnalyzer(
  '{{ name | snake_case }}_analyzer',
  {
    workerTemplate: '{{ name | snake_case }}_batch',
    inputs: { totalItems: 'total_items' },
  },
  async ({ totalItems, context }) => {
    // TODO: Determine total items from your data source
    const count = Number(totalItems) || 1000;
    const batchSize = 200;

    return { totalItems: count, batchSize };
  },
);

export const {{ name | pascal_case }}WorkerHandler = defineBatchWorker(
  '{{ name | snake_case }}_worker',
  {},
  async ({ batchContext }) => {
    // TODO: Process items in the batch range
    const cursor = batchContext?.cursorConfig;
    const itemsProcessed = (cursor?.endCursor ?? 0) - (cursor?.startCursor ?? 0);

    return {
      itemsProcessed,
      batchId: cursor?.batchId,
    };
  },
);

/**
 * Convergence step â€” aggregates results from all batch workers.
 * Runs automatically after all batch workers complete.
 * context.getAllDependencyResults() collects results by worker name prefix.
 */
export const {{ name | pascal_case }}ConvergenceHandler = defineHandler(
  '{{ name | snake_case }}_convergence',
  {},
  async ({ context }) => {
    const batchResults = context.getAllDependencyResults(
      '{{ name | snake_case }}_batch',
    ) as Array<Record<string, unknown> | null>;

    let totalProcessed = 0;
    const workerCount = batchResults?.length ?? 0;

    for (const result of batchResults ?? []) {
      if (result) {
        totalProcessed += (result.itemsProcessed as number) ?? 0;
      }
    }

    // TODO: Add your domain-specific aggregation logic here
    return {
      totalProcessed,
      workerCount,
    };
  },
);
