# frozen_string_literal: true

require 'tasker_core/step_handler'

module {{ module_name }}
  # {{ name | pascal_case }} batchable step handlers for parallel processing.
  #
  # Workflow pattern:
  #   1. Analyzer step: returns BatchConfig to divide work into batches
  #   2. Worker steps: process individual batches in parallel
  #   3. Convergence step: aggregates results from all workers
  #
  # Register handlers in your task definition YAML:
  #   - name: {{ name | snake_case }}_analyze
  #     type: batchable
  #     handler:
  #       callable: {{ module_name }}::{{ name | pascal_case }}AnalyzerHandler
  #   - name: {{ name | snake_case }}_batch
  #     type: batch_worker
  #     dependencies: [{{ name | snake_case }}_analyze]
  #     handler:
  #       callable: {{ module_name }}::{{ name | pascal_case }}WorkerHandler
  #   - name: {{ name | snake_case }}_converge
  #     type: deferred_convergence
  #     dependencies: [{{ name | snake_case }}_batch]
  #     handler:
  #       callable: {{ module_name }}::{{ name | pascal_case }}ConvergenceHandler
  include TaskerCore::StepHandler::Functional

  {{ name | pascal_case }}AnalyzerHandler = batch_analyzer '{{ name | snake_case }}_analyzer',
    worker_template: '{{ name | snake_case }}_batch',
    inputs: [:total_items] do |total_items:, context:|

    # TODO: Determine total items from your data source
    count = total_items&.to_i || 1000
    batch_size = 200

    BatchConfig.new(total_items: count, batch_size: batch_size)
  end

  {{ name | pascal_case }}WorkerHandler = batch_worker '{{ name | snake_case }}_worker' do |batch_context:, context:|
    # TODO: Process items in the batch range
    cursor = batch_context&.dig(:cursor_config)
    items_processed = (cursor[:end_cursor] || 0) - (cursor[:start_cursor] || 0)

    {
      items_processed: items_processed,
      batch_id: cursor[:batch_id]
    }
  end

  # Convergence step â€” aggregates results from all batch workers.
  # Runs automatically after all batch workers complete.
  {{ name | pascal_case }}ConvergenceHandler = step_handler '{{ name | snake_case }}_convergence' do |context:|
    total_processed = 0
    worker_count = 0

    context.dependency_results.each do |dep_name, _|
      next unless dep_name.start_with?('{{ name | snake_case }}_batch_')

      result = context.get_dependency_result(dep_name)
      next unless result.is_a?(Hash)

      total_processed += result['items_processed'] || 0
      worker_count += 1
    end

    # TODO: Add your domain-specific aggregation logic here
    {
      total_processed: total_processed,
      worker_count: worker_count
    }
  end
end
